---
layout: post
title:  'WebGL实战'
date:   2018-04-14 18:23:00 +0800
author: "杨磊"
categories: yanglei
---

前文已经大概讲解了一些基础知识，涵盖了WebGL创建，着色器，着色器编程以及缓存区等知识，一些简单的点面效果即可以基于此来完成，接下来让我们绘制一下如下的效果：

![WebGL波浪效果](/assets/img/yanglei10-1.gif)

让我们先准备一下前期的WebGL内容

首先让我们来创建一个可以接受参数的着色器
{% highlight ruby %}
var VSHADER_SOURCE =`
    attribute vec4 a_p;
    attribute float size;
    void main() {
        gl_Position = a_p;
        gl_PointSize = size;
    }
`;
var FSHADER_SOURCE =`
    #ifdef GL_ES
    precision mediump float;
    #endif
    uniform vec4 color;
    void main(){
        float d = distance(gl_PointCoord, vec2(0.5,0.5));
        if(d < 0.5){
            gl_FragColor = color;
        }else{ discard;}
    }
`;
var canvas = document.getElementById("glcanvas");
gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
var program = gl.createProgram();
// 创建顶点着色器 
var vShader = gl.createShader(gl.VERTEX_SHADER);
// 创建片元着色器 
var fShader = gl.createShader(gl.FRAGMENT_SHADER);
// shader容器与着色器绑定 
gl.shaderSource(vShader, VSHADER_SOURCE);
gl.shaderSource(fShader, FSHADER_SOURCE);
// 将GLSE语言编译成浏览器可用代码 
gl.compileShader(vShader);
gl.compileShader(fShader);
// 将着色器添加到程序上 
gl.attachShader(program, vShader);
gl.attachShader(program, fShader);
// 链接程序，在链接操作执行以后，可以任意修改shader的源代码，
对shader重新编译不会影响整个程序，除非重新链接程序 
gl.linkProgram(program);
// 加载并使用链接好的程序 
gl.useProgram(program);
{% endhighlight %}

接下来，我们需要创建多个点的坐标，所有点在同一行时，只有X坐标是变化的，y是相同的。

但因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：

![WebGL坐标系与普通canvas坐标系](/assets/img/yanglei12-1.jpg)

然后你知道了这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：

{% highlight ruby %}
//错误
<canvas id="glcanvas" style="width: 700px; height: 500px;">
//正确的方式
<canvas id="glcanvas" width="700" height="500">
{% endhighlight %}

首先我们需要先将对应的真实坐标转换成WebGL坐标，因为canvas宽度的一半对应为WebGL的1.0尺寸。所以将真实像素除以宽度的一半就可以得到对应的WebGL尺寸，高度与宽度的处理方式一致。
{% highlight ruby %}
function webglX (num) {
    return num/(width/2);
};
function webglY (num) {
    return num/(height/2);
}
{% endhighlight %}

有了转换坐标尺寸的函数，接下来我们开始准备多个点的信息。来绘制10行，每行100个点。
{% highlight ruby %}
 function createPoints() {
    //波动最大幅度 10px;
    var arr = [];
    var n = 100;
    var m = 10;
    for(var i = 0; i < n; i++) {
        for(var j = 0; j < m; j++) {
            var x = webglX(-(width/2) + i*20);
            var y = webglY((height/2) - j*20);
            var z = -1;
            var item = [x, y, z];
            arr = arr.concat(item);
        }
    }
    return new Float32Array(arr)
}
{% endhighlight %}

因为WebGL坐标的中心点在整个canvas中心，所以x的坐标会从-(width/2)高度一半的负值开始。，高度我们希望在容器最底层，所以使用(height/2)高度的一半为开始点。点与点之间的左右上线距离均为20像素。因为此在一个平面，所以z相同。

有了点，那么我们就可以使用先前讲过的缓存区开始批量绘制点了。
{% highlight ruby %}
var vertexBuffer = gl.createBuffer();
if(!vertexBuffer) {
    log('创建缓存区失败。');
    return -1;
}
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, createPoints(), gl.STATIC_DRAW);
var a_position = gl.getAttribLocation(gl.program, 'a_p');
//因为数据传递的为三维数据，故我们需要指定设置缓存区的解析维度
gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(a_position);
gl.clearColor(0.0,0.0,0.0,1.0);
gl.clear(gl.COLOR_BUFFER_BIT);
//我们需要告诉程序，我们具体需要绘制多少个点
gl.drawArrays(gl.POINTS, 0 , 1000);
{% endhighlight %}
